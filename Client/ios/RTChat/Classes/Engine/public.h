#pragma once


// Turn off warnings generated by long std templates
// This warns about truncation to 255 characters in debug/browse info
#   pragma warning (disable : 4786)

// Turn off warnings generated by long std templates
// This warns about truncation to 255 characters in debug/browse info
#   pragma warning (disable : 4503)

// disable: "conversion from 'double' to 'float', possible loss of data
#   pragma warning (disable : 4244)

// disable: "warning C4200: 使用了非标准扩展 : 结构/联合中的零大小数组
#   pragma warning (disable : 4200)

// disable: "truncation from 'double' to 'float'
#   pragma warning (disable : 4305)

// disable: "<type> needs to have dll-interface to be used by clients'
// Happens on STL member variables which are not public therefore is ok
#   pragma warning (disable : 4251)

// disable: "non dll-interface class used as base for dll-interface class"
// Happens when deriving from Singleton because bug in compiler ignores
// template export
#   pragma warning (disable : 4275)

// disable: "C++ Exception Specification ignored"
// This is because MSVC 6 did not implement all the C++ exception
// specifications in the ANSI C++ draft.
#   pragma warning( disable : 4290 )

// disable: "no suitable definition provided for explicit template
// instantiation request" Occurs in VC7 for no justifiable reason on all
// #includes of Singleton
#   pragma warning( disable: 4661)

// disable: deprecation warnings when using CRT calls in VC8
// These show up on all C runtime lib code in VC8, disable since they clutter
// the warnings with things we may not be able to do anything about (e.g.
// generated code from nvparse etc). I doubt very much that these calls
// will ever be actually removed from VC anyway, it would break too much code.
#	pragma warning( disable: 4996)

// disable: "conditional expression constant", always occurs on 
// OGRE_MUTEX_CONDITIONAL when no threading enabled
#   pragma warning (disable : 201)


#include <assert.h>
#include <math.h>
#include <strings.h>
#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <functional>
#include <stdlib.h>

typedef std::string String;
typedef std::vector<String> StringVector;
typedef int Real;

typedef uint64_t QWORD;
typedef unsigned char   BYTE;
typedef unsigned char   byte;
typedef unsigned short  WORD;
typedef unsigned int    DWORD;
typedef signed int SDWORD;

typedef signed char     INT8;
typedef signed short    INT16;
typedef signed int      INT32;
typedef signed long long INT64;

#define MAX_DATASIZE    4096

#define RGBA(r,g,b,a)	((DWORD(a)<<24) + (DWORD(b)<<16) + (DWORD(g)<<8) + DWORD(r))
#define ARGB(a,r,g,b)	((DWORD(a)<<24) + (DWORD(r)<<16) + (DWORD(g)<<8) + DWORD(b))
#define AL(a,l)  ((WORD(a)<<8) + WORD(l))
#define XRGB(r,g,b)	((DWORD(-1)<<24) + (DWORD(r)<<16) + (DWORD(g)<<8) + DWORD(b))
#define GETA(col)		((col)>>24)
#define GETR(col)		( (col & 0x00FF0000) >> 16 )
#define GETG(col)		( (col & 0x0000FF00) >> 8 )
#define GETB(col)		((col) & 0x000000FF)
#define SETA(col,a)		(((col) & 0x00FFFFFF) + (DWORD(a)<<24))
#define SETR(col,r)		(((col) & 0xFF00FFFF) + (DWORD(r)<<16))
#define SETG(col,g)		(((col) & 0xFFFF00FF) + (DWORD(g)<<8))
#define SETB(col,b)		(((col) & 0xFFFFFF00) + DWORD(b))

#define count_of(theArray) (sizeof(theArray[0]) == 0 ? 0 : sizeof(theArray) / sizeof(theArray[0]))

#define UPROUNDTO(num,roundTo) ( ((DWORD)((DWORD)num + roundTo-1)) & (~((DWORD)roundTo-1)) )

#define LOWROUNDTO(num,roundTo) ( ((DWORD)num) & (~((DWORD)roundTo-1)) )


#define LINKDWORD(high,low) ( (((DWORD)high)<<16) | ((DWORD)low) )

#define LINKWORD( high, low )   ( (((WORD)(BYTE)high)<<8) | ((WORD)(BYTE)low) )

#define GETHIGHDWORD(dword) (dword>>16)
#define GETLOWDWORD(dword) (dword&0x0000FFFF)


#define GETHIGHWORD(word) (word>>8)
#define GETLOWWORD(word) (word&0x00FF)

#define SIZEOF(theArray) (sizeof(theArray[0]) == 0 ? 0 : sizeof(theArray) / sizeof(theArray[0]))

#ifndef MAX
#define MAX(a,b) (a >= b ? a : b)
#endif

#ifndef MIN
#define MIN(a,b) (a >=b ? b : a)
#endif

#define MINFLOAT 0.0000001

#define ANGLE2RADIAN( angle ) ( (angle) * PI / 180.f )
#define RADIAN2ANGLE( radian ) ( (radian) / PI * 180.f )

#define SAFE_DELETE(p) if (p) {delete (p); (p) = 0;}
#define SAFE_DELETEARRAY(p) if (p) { delete [] p; (p) = 0; }
#define SAFE_RELEASE(p) if (p) {(p)->Release(); (p) = 0;}

#define  BSWAP_16(x) \
     (WORD) ( ((((WORD)(x)) & 0x00ff) << 8 ) | \
                 ((((WORD)(x)) & 0xff00) >> 8 ) \
          )

#define BSWAP_32(x) \
     (DWORD) ( (( ((DWORD)(x)) & 0xff000000 ) >> 24) | \
                    (( ((DWORD)(x)) & 0x00ff0000 ) >> 8 ) | \
     (( ((DWORD)(x)) & 0x0000ff00 ) << 8 ) | \
     (( ((DWORD)(x)) & 0x000000ff ) << 24) \
              )


#define BEGIN_HRESULT_CHECK \
HRESULT res = S_OK; \
do \
{

#define END_HRESULT_CHECK \
} while(false);

#define BEGIN_BOOL_CHECK \
bool res = true \
do \
{

#define END_BOOL_CHECK \
} while(false);

#define RETURN_CHECK return res;
#define RETURN_HRESULT_FAIL if ( res != S_OK ) return res

#define BREAK_IF_FAIL(p) { if (((res)=p) != S_OK) break; }
#define BREAK_IF_FALSE(p) { if (((res)=p) != true) break; }

#ifndef M_PI
	#define M_PI	3.14159265358979323846f
	#define M_PI_2	1.57079632679489661923f
	#define M_PI_4	0.785398163397448309616f
	#define M_1_PI	0.318309886183790671538f
	#define M_2_PI	0.636619772367581343076f
#endif

#define DECLARE_DERIVED_CLASS(BaseClass) \
protected: \
	virtual bool _isKindOf(const String &classType) \
	{ \
		if (classType == msClassTypeName) \
			return true; \
		return BaseClass::_isKindOf(classType); \
	} \
public: \
	static String msClassTypeName; \
public: \
    virtual String getTypeName() \
	{ \
		return msClassTypeName; \
	} \
	template <typename T> \
	bool isKindOf() \
	{ \
		return _isKindOf(T::msClassTypeName); \
	} \
	template <typename T> \
	bool isKind() \
	{ \
		return getTypeName() == T::msClassTypeName; \
	} 

#define DECLARE_BASE_CLASS(BaseClass) \
protected: \
	virtual bool _isKindOf(const String &classType) \
	{ \
		if (classType == msClassTypeName) \
			return true; \
		return false; \
	} \
public: \
	static String msClassTypeName; \
public: \
    virtual String getTypeName()\
	{ \
		return msClassTypeName; \
	} \
	template <typename T> \
	bool isKindOf() \
	{ \
		return _isKindOf(T::msClassTypeName); \
	}\
	template <typename T> \
	bool isKind() \
	{ \
		return getTypeName() == T::msClassTypeName; \
	}

#define DEFINE_CLASS(DerivedClass) String DerivedClass::msClassTypeName = #DerivedClass;


const char *avar(const char *pszFmt,...);

inline void SetBit( BYTE *pByte, DWORD bit )
{
	pByte[bit/8] &= (0xFF & (1<<(bit%8)));
}
inline void ClearBit( BYTE *pByte, DWORD bit )
{
	pByte[bit/8] &= (0xFF & (~(1<<(bit%8))));
}
inline bool IsSet( BYTE *pByte, DWORD bit )
{
	return 0 != (pByte[bit/8] & (0xFF & (1<<(bit%8))));
}

template <typename Type, typename DefaultValue >
void AutoResizeVector( std::vector<Type> &container, size_t index, DefaultValue value )
{
	if ( index >= container.size() )
	{
		for (size_t i=container.size(); i<=index; ++i)
		{
			container.push_back( value );
		}
	}

}